// __multiversion__
#include "fragmentVersionCentroid.h"

#if __VERSION__ >= 300
	#ifndef BYPASS_PIXEL_SHADER
		#if defined(TEXEL_AA) && defined(TEXEL_AA_FEATURE)
			_centroid in highp vec2 uv0;
			_centroid in vec2 uv1;
		#else
			_centroid in highp vec2 uv0;
			_centroid in vec2 uv1;
		#endif
	#endif
#else
	#ifndef BYPASS_PIXEL_SHADER
		varying highp vec2 uv0;
		varying vec2 uv1;
	#endif
#endif

varying vec4 vcolor;

#include "uniformPerFrameConstants.h"
#include "uniformShaderConstants.h"
#include "util.h"
#include "functionIncludes.glsl"

#ifdef FOG
	varying float fca;
#endif

varying vec3 cpos;
varying vec3 wpos;

LAYOUT_BINDING(0) uniform sampler2D TEXTURE_0;
LAYOUT_BINDING(1) uniform sampler2D TEXTURE_1;
LAYOUT_BINDING(2) uniform sampler2D TEXTURE_2;

void main()
{

#ifdef BYPASS_PIXEL_SHADER
	gl_FragColor = vec4(0, 0, 0, 0);
	return;
#else

	vec2 suv0 = fract(uv0 * 32.0) * (1.0 / 64.0);
	vec2 suv1 = suv0 - vec2(0.0, 1.0 / 64.0);
	vec2 suv2 = suv0 - vec2(1.0 / 64.0, 0.0);

	vec3 n = normalize(cross(dFdx(cpos.xyz), dFdy(cpos.xyz)));
	vec3 t = normalize(getTangentVector(n));
	vec3 b = normalize(cross(t,n));
	mat3 tbn = mat3(t.x, b.x, n.x, t.y, b.y, n.y, t.z, b.z, n.z);

	vec4 mert = texelFetch(TEXTURE_0, ivec2((uv0 - suv2) * TEXTURE_DIMENSIONS.xy), 0);
	vec3 mer = vec3(0.0, 0.0, 0.0);
	if(mert.r > 0.0 || mert.g > 0.0 || mert.b > 0.0) mer = mert.rgb;
	float met = saturate(mer.g);
	float rough = saturate(pow(1.0-mer.r, 2.0));
	float ssm = saturate(1.0-rough * 3.0);

	vec4 ntex = texture2D(TEXTURE_0, uv0 - suv1);
	vec3 nmap = vec3(0.0, 0.0, 1.0) * 0.5 + 0.5;
	if(ntex.r > 0.0 || ntex.g > 0.0 || ntex.b > 0.0) nmap = ntex.rgb;
		nmap = nmap * 2.0 - 1.0;
		nmap.rg *= max0(1.5-wrain * 1.3);
		nmap = normalize(nmap * tbn);

	vec3 lp = normalize(vec3(cos(sunLightAngle), sin(sunLightAngle), 0.0));
	vec3 vd = normalize(-wpos.xyz);
	vec3 hd = normalize(vd + lp);
	vec3 rv = reflect(normalize(wpos.xyz), nmap);
	vec3 up = normalize(vec3(0.0, abs(wpos.y), 0.0));

	float ndl = max0(dot(nmap, lp));
	float ndv = max(0.001, dot(nmap, vd));
	float ndh = max(0.001, dot(nmap, hd));
	float tb = texture2D(TEXTURE_1, vec2(0, 1)).r;
	float zs = max0(dot(rv, up));
	float sm = min(pow(uv1.y * 1.15, 128.0), 1.0);

	vec4 albedo = texelFetch(TEXTURE_0, ivec2((uv0 - suv0) * TEXTURE_DIMENSIONS.xy), 0);
	#ifdef SEASONS_FAR
		albedo.a = 1.0;
	#endif
	#if USE_ALPHA_TEST
		#ifdef ALPHA_TO_COVERAGE
			#define ALPHA_THRESHOLD 0.05
		#else
			#define ALPHA_THRESHOLD 0.5
		#endif
		if(albedo.a < ALPHA_THRESHOLD) discard;
	#endif
	#if defined(BLEND)
		albedo.a *= vcolor.a;
	#endif
	#ifndef SEASONS
		#if !USE_ALPHA_TEST && !defined(BLEND)
			albedo.a = vcolor.a;
		#endif
		vec3 nvcolor = normalize(vcolor.rgb);
		if(nvcolor.g > nvcolor.b && vcolor.a == 1.0){
			albedo.rgb *= mix(nvcolor, vcolor.rgb, 0.5);
		} else {
			albedo.rgb *= vcolor.a == 0.0 ? vcolor.rgb : sqrt(vcolor.rgb);
		}
	#else
		albedo.rgb *= mix(vec3(1.0,1.0,1.0), texture2D(TEXTURE_2, vcolor.rg).rgb * 2.0, vcolor.b);
		albedo.rgb *= vcolor.aaa;
		albedo.a = 1.0;
	#endif
		albedo.rgb = toLinear(albedo.rgb);

	vec3 amb = toLinear(FOG_COLOR.rgb) * (0.5 + wrain * 1.8) * uv1.y;
	vec3 abl = albedo.rgb;
	float alb = smoothstep(tb * uv1.y, 1.0, uv1.x);
	float bls;
		bls = mix(mix(bls, uv1.x, alb), uv1.x, wrain);
		amb += vec3(1.0, 0.5, 0.2) * bls + pow(bls * 1.15, 5.0);
	vec3 dl = vec3(FOG_COLOR.r, FOG_COLOR.g * 0.9, FOG_COLOR.b * 0.8) * pow(ndl, 0.5) * 3.0;
		amb += dl * sm * (1.0-wrain);
	vec3 fc = renderSkyColor(normalize(wpos), up, 1.0);
	vec3 scr = renderSkyColor(rv, up, 1.5);
		scr = mix(scr, scr * albedo.rgb, met);
	vec3 f0 = mix(vec3(0.04), albedo.rgb, met);
	vec3 vf = fresnelSchlick(f0, ndv);
	float nd = ditributionGGX(rough, ndh);
	float g = geometrySchlick(rough, ndv, ndl);
	float att = (1.0 - rough) * g * nd;

		albedo.rgb = (albedo.rgb * amb) + (saturate(mer.b) * abl * 5.0);
		albedo.rgb = mix(albedo.rgb, albedo.rgb * 0.0, met);
		albedo = mix(albedo, vec4(scr, 1.0), length(vf) * max(max(met, ssm), wrain * n.y) * sm);
		albedo += att * ndl * vec4(vec3(FOG_COLOR.r, FOG_COLOR.g * 0.9, FOG_COLOR.b * 0.8) * 2.0, 1.0) * sm * (1.0-wrain);
	if(FOG_CONTROL.x > 0.5) albedo.rgb = mix(albedo.rgb, fc * vec3(0.4, 0.7, 1.0), max0(length(wpos)/RENDER_DISTANCE) * 0.5);
		albedo.rgb = mix(albedo.rgb, fc, max0(length(wpos)/100.0) * wrain);

	#ifdef FOG
		albedo.rgb = mix(albedo.rgb, fc, fca);
	#endif

		albedo.rgb = tonemap(albedo.rgb);

	gl_FragColor = albedo;

#endif // !BYPASS_PIXEL_SHADER
}
